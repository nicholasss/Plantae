// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one
insert into users (
  id, created_at, updated_at,
  created_by, updated_by, join_date,
  is_admin, email, hashed_password
) values (
  gen_random_uuid(), now(), now(),
  $1, $2, now(),
  false, $3, $4
) returning id, created_at, updated_at, created_by, updated_by, join_date, is_admin, email
`

type CreateUserParams struct {
	CreatedBy      string `json:"created_by"`
	UpdatedBy      string `json:"updated_by"`
	Email          string `json:"email"`
	HashedPassword string `json:"hashed_password"`
}

type CreateUserRow struct {
	ID        uuid.UUID `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	CreatedBy string    `json:"created_by"`
	UpdatedBy string    `json:"updated_by"`
	JoinDate  time.Time `json:"join_date"`
	IsAdmin   bool      `json:"is_admin"`
	Email     string    `json:"email"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.Email,
		arg.HashedPassword,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.JoinDate,
		&i.IsAdmin,
		&i.Email,
	)
	return i, err
}

const demoteUserFromAdminByID = `-- name: DemoteUserFromAdminByID :exec
update users
set
  is_admin = false
where
  id = $1
`

func (q *Queries) DemoteUserFromAdminByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, demoteUserFromAdminByID, id)
	return err
}

const getAllUsersWithoutPasswordByJoinDate = `-- name: GetAllUsersWithoutPasswordByJoinDate :many
select
  id, created_at, updated_at,
  created_by, updated_by,
  is_admin, email
from users
  where deleted_at is null
  order by join_date asc
`

type GetAllUsersWithoutPasswordByJoinDateRow struct {
	ID        uuid.UUID `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	CreatedBy string    `json:"created_by"`
	UpdatedBy string    `json:"updated_by"`
	IsAdmin   bool      `json:"is_admin"`
	Email     string    `json:"email"`
}

func (q *Queries) GetAllUsersWithoutPasswordByJoinDate(ctx context.Context) ([]GetAllUsersWithoutPasswordByJoinDateRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsersWithoutPasswordByJoinDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersWithoutPasswordByJoinDateRow
	for rows.Next() {
		var i GetAllUsersWithoutPasswordByJoinDateRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.IsAdmin,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersWithoutPasswordByUpdated = `-- name: GetAllUsersWithoutPasswordByUpdated :many
select
  id, created_at, updated_at,
  created_by, updated_by,
  is_admin, email
from users
  where deleted_at is null
  order by updated_at desc
`

type GetAllUsersWithoutPasswordByUpdatedRow struct {
	ID        uuid.UUID `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	CreatedBy string    `json:"created_by"`
	UpdatedBy string    `json:"updated_by"`
	IsAdmin   bool      `json:"is_admin"`
	Email     string    `json:"email"`
}

func (q *Queries) GetAllUsersWithoutPasswordByUpdated(ctx context.Context) ([]GetAllUsersWithoutPasswordByUpdatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsersWithoutPasswordByUpdated)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersWithoutPasswordByUpdatedRow
	for rows.Next() {
		var i GetAllUsersWithoutPasswordByUpdatedRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.IsAdmin,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmailWithPassword = `-- name: GetUserByEmailWithPassword :one
select id, created_at, updated_at, deleted_at, created_by, updated_by, deleted_by, join_date, is_admin, email, hashed_password from users
  where email like $1
  and deleted_at is null
  limit 1
`

func (q *Queries) GetUserByEmailWithPassword(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailWithPassword, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.JoinDate,
		&i.IsAdmin,
		&i.Email,
		&i.HashedPassword,
	)
	return i, err
}

const getUserByEmailWithoutPassword = `-- name: GetUserByEmailWithoutPassword :one
select 
  id, created_at, updated_at,
  created_by, updated_by,
  is_admin, email
from users
  where email like $1
  and deleted_at is null
  limit 1
`

type GetUserByEmailWithoutPasswordRow struct {
	ID        uuid.UUID `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	CreatedBy string    `json:"created_by"`
	UpdatedBy string    `json:"updated_by"`
	IsAdmin   bool      `json:"is_admin"`
	Email     string    `json:"email"`
}

func (q *Queries) GetUserByEmailWithoutPassword(ctx context.Context, email string) (GetUserByEmailWithoutPasswordRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailWithoutPassword, email)
	var i GetUserByEmailWithoutPasswordRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.IsAdmin,
		&i.Email,
	)
	return i, err
}

const getUserByIDWithPassword = `-- name: GetUserByIDWithPassword :one
select id, created_at, updated_at, deleted_at, created_by, updated_by, deleted_by, join_date, is_admin, email, hashed_password from users
  where id = $1
  and deleted_at is null
  limit 1
`

func (q *Queries) GetUserByIDWithPassword(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByIDWithPassword, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.JoinDate,
		&i.IsAdmin,
		&i.Email,
		&i.HashedPassword,
	)
	return i, err
}

const getUserByIDWithoutPassword = `-- name: GetUserByIDWithoutPassword :one
select 
  id, created_at, updated_at,
  created_by, updated_by,
  is_admin, email
from users
  where id = $1
  and deleted_at is null
  limit 1
`

type GetUserByIDWithoutPasswordRow struct {
	ID        uuid.UUID `json:"id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
	CreatedBy string    `json:"created_by"`
	UpdatedBy string    `json:"updated_by"`
	IsAdmin   bool      `json:"is_admin"`
	Email     string    `json:"email"`
}

func (q *Queries) GetUserByIDWithoutPassword(ctx context.Context, id uuid.UUID) (GetUserByIDWithoutPasswordRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByIDWithoutPassword, id)
	var i GetUserByIDWithoutPasswordRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.IsAdmin,
		&i.Email,
	)
	return i, err
}

const promoteUserToAdminByID = `-- name: PromoteUserToAdminByID :exec
update users
set
  is_admin = true
where
  id = $1
`

func (q *Queries) PromoteUserToAdminByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, promoteUserToAdminByID, id)
	return err
}

const resetUsersTable = `-- name: ResetUsersTable :exec
delete from users
`

func (q *Queries) ResetUsersTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, resetUsersTable)
	return err
}

const updateUserPasswordByID = `-- name: UpdateUserPasswordByID :exec
update users
set
  hashed_password = $2
where
  id = $1
`

type UpdateUserPasswordByIDParams struct {
	ID             uuid.UUID `json:"id"`
	HashedPassword string    `json:"hashed_password"`
}

func (q *Queries) UpdateUserPasswordByID(ctx context.Context, arg UpdateUserPasswordByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPasswordByID, arg.ID, arg.HashedPassword)
	return err
}
