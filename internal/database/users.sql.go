// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one
insert into users (
  id, created_at, updated_at,
  created_by, updated_by,
  is_admin, email, hashed_password
) values (
  gen_random_uuid(), now(), now(),
  $1, $2, $3, $4, $5
) returning id, created_at, updated_at, deleted_at, created_by, updated_by, deleted_by, join_date, is_admin, email, hashed_password
`

type CreateUserParams struct {
	CreatedBy      time.Time
	UpdatedBy      sql.NullTime
	IsAdmin        bool
	Email          string
	HashedPassword sql.NullString
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.IsAdmin,
		arg.Email,
		arg.HashedPassword,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.JoinDate,
		&i.IsAdmin,
		&i.Email,
		&i.HashedPassword,
	)
	return i, err
}

const getAllUserWithoutPasswordByUpdated = `-- name: GetAllUserWithoutPasswordByUpdated :many
select
  id, created_at, updated_at,
  created_by, updated_by,
  is_admin, email
from users
  where deleted_at is null
  order by updated_at desc
`

type GetAllUserWithoutPasswordByUpdatedRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	CreatedBy time.Time
	UpdatedBy sql.NullTime
	IsAdmin   bool
	Email     string
}

func (q *Queries) GetAllUserWithoutPasswordByUpdated(ctx context.Context) ([]GetAllUserWithoutPasswordByUpdatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserWithoutPasswordByUpdated)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserWithoutPasswordByUpdatedRow
	for rows.Next() {
		var i GetAllUserWithoutPasswordByUpdatedRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.IsAdmin,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmailWithPassword = `-- name: GetUserByEmailWithPassword :one
select id, created_at, updated_at, deleted_at, created_by, updated_by, deleted_by, join_date, is_admin, email, hashed_password from users
  where email like $1
  and deleted_at is null
  limit 1
`

func (q *Queries) GetUserByEmailWithPassword(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailWithPassword, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.JoinDate,
		&i.IsAdmin,
		&i.Email,
		&i.HashedPassword,
	)
	return i, err
}

const getUserByEmailWithoutPassword = `-- name: GetUserByEmailWithoutPassword :one
select 
  id, created_at, updated_at,
  created_by, updated_by,
  is_admin, email
from users
  where email like $1
  and deleted_at is null
  limit 1
`

type GetUserByEmailWithoutPasswordRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	CreatedBy time.Time
	UpdatedBy sql.NullTime
	IsAdmin   bool
	Email     string
}

func (q *Queries) GetUserByEmailWithoutPassword(ctx context.Context, email string) (GetUserByEmailWithoutPasswordRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmailWithoutPassword, email)
	var i GetUserByEmailWithoutPasswordRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.IsAdmin,
		&i.Email,
	)
	return i, err
}

const getUserByIDWithPassword = `-- name: GetUserByIDWithPassword :one
select id, created_at, updated_at, deleted_at, created_by, updated_by, deleted_by, join_date, is_admin, email, hashed_password from users
  where id like $1
  and deleted_at is null
  limit 1
`

func (q *Queries) GetUserByIDWithPassword(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByIDWithPassword, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.JoinDate,
		&i.IsAdmin,
		&i.Email,
		&i.HashedPassword,
	)
	return i, err
}

const getUserByIDWithoutPassword = `-- name: GetUserByIDWithoutPassword :one
select 
  id, created_at, updated_at,
  created_by, updated_by,
  is_admin, email
from users
  where id like $1
  and deleted_at is null
  limit 1
`

type GetUserByIDWithoutPasswordRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	CreatedBy time.Time
	UpdatedBy sql.NullTime
	IsAdmin   bool
	Email     string
}

func (q *Queries) GetUserByIDWithoutPassword(ctx context.Context, id uuid.UUID) (GetUserByIDWithoutPasswordRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByIDWithoutPassword, id)
	var i GetUserByIDWithoutPasswordRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.IsAdmin,
		&i.Email,
	)
	return i, err
}
