// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users_plants.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createUsersPlants = `-- name: CreateUsersPlants :one
with inserted_users_plant as (
  insert into users_plants (
    id,
    created_at, updated_at,
    created_by, updated_by,
    plant_id, user_id,
    adoption_date, name
  ) values (
    gen_random_uuid(),
    now(), now(),
    $1, $1,
    $2, $3,
    $4, $5
  ) returning 
    id, plant_id, user_id,
    adoption_date, name
  )
select
  iup.id as users_plant_id,
  iup.adoption_date,
  iup.name as plant_name,
  ps.id as species_id,
  ps.species_name as plant_species_name
from
  inserted_users_plant as iup
join
  plant_species as ps on iup.plant_id = ps.id
`

type CreateUsersPlantsParams struct {
	CreatedBy    uuid.UUID      `json:"createdBy"`
	PlantID      uuid.UUID      `json:"plantID"`
	UserID       uuid.UUID      `json:"userID"`
	AdoptionDate sql.NullTime   `json:"adoptionDate"`
	Name         sql.NullString `json:"name"`
}

type CreateUsersPlantsRow struct {
	UsersPlantID     uuid.UUID      `json:"usersPlantID"`
	AdoptionDate     sql.NullTime   `json:"adoptionDate"`
	PlantName        sql.NullString `json:"plantName"`
	SpeciesID        uuid.UUID      `json:"speciesID"`
	PlantSpeciesName string         `json:"plantSpeciesName"`
}

func (q *Queries) CreateUsersPlants(ctx context.Context, arg CreateUsersPlantsParams) (CreateUsersPlantsRow, error) {
	row := q.db.QueryRowContext(ctx, createUsersPlants,
		arg.CreatedBy,
		arg.PlantID,
		arg.UserID,
		arg.AdoptionDate,
		arg.Name,
	)
	var i CreateUsersPlantsRow
	err := row.Scan(
		&i.UsersPlantID,
		&i.AdoptionDate,
		&i.PlantName,
		&i.SpeciesID,
		&i.PlantSpeciesName,
	)
	return i, err
}

const deleteUsersPlantByID = `-- name: DeleteUsersPlantByID :exec
update users_plants
set
  deleted_at = now(),
  deleted_by = $2,
  updated_at = now(),
  updated_by = $2
where id = $1
  and deleted_at is null
`

type DeleteUsersPlantByIDParams struct {
	ID        uuid.UUID     `json:"id"`
	DeletedBy uuid.NullUUID `json:"deletedBy"`
}

func (q *Queries) DeleteUsersPlantByID(ctx context.Context, arg DeleteUsersPlantByIDParams) error {
	_, err := q.db.ExecContext(ctx, deleteUsersPlantByID, arg.ID, arg.DeletedBy)
	return err
}

const getAllUsersPlantsOrderedByCreated = `-- name: GetAllUsersPlantsOrderedByCreated :many
with users_plant as (
  select 
    id, plant_id, adoption_date, name, created_at
  from users_plants
  where
    deleted_at is null and
    user_id = $1
)
select
  up.id as users_plant_id,
  up.adoption_date,
  up.name as plant_name,
  up.created_at,
  ps.id as plant_species_id,
  ps.species_name
from
  users_plant as up
join
  plant_species as ps on up.plant_id = ps.id
order by up.created_at desc
`

type GetAllUsersPlantsOrderedByCreatedRow struct {
	UsersPlantID   uuid.UUID      `json:"usersPlantID"`
	AdoptionDate   sql.NullTime   `json:"adoptionDate"`
	PlantName      sql.NullString `json:"plantName"`
	CreatedAt      time.Time      `json:"createdAt"`
	PlantSpeciesID uuid.UUID      `json:"plantSpeciesID"`
	SpeciesName    string         `json:"speciesName"`
}

func (q *Queries) GetAllUsersPlantsOrderedByCreated(ctx context.Context, userID uuid.UUID) ([]GetAllUsersPlantsOrderedByCreatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsersPlantsOrderedByCreated, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersPlantsOrderedByCreatedRow
	for rows.Next() {
		var i GetAllUsersPlantsOrderedByCreatedRow
		if err := rows.Scan(
			&i.UsersPlantID,
			&i.AdoptionDate,
			&i.PlantName,
			&i.CreatedAt,
			&i.PlantSpeciesID,
			&i.SpeciesName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersPlantsOrderedByUpdated = `-- name: GetAllUsersPlantsOrderedByUpdated :many
with users_plant as (
  select
    id, plant_id, adoption_date, name, updated_at
  from users_plants
  where
    deleted_at is null and
    user_id = $1
)
select
  up.id as users_plant_id,
  up.adoption_date,
  up.name as plant_name,
  up.updated_at,
  ps.id as plant_species_id,
  ps.species_name
from
  users_plant as up
join
  plant_species as ps on up.plant_id = ps.id
order by up.updated_at desc
`

type GetAllUsersPlantsOrderedByUpdatedRow struct {
	UsersPlantID   uuid.UUID      `json:"usersPlantID"`
	AdoptionDate   sql.NullTime   `json:"adoptionDate"`
	PlantName      sql.NullString `json:"plantName"`
	UpdatedAt      time.Time      `json:"updatedAt"`
	PlantSpeciesID uuid.UUID      `json:"plantSpeciesID"`
	SpeciesName    string         `json:"speciesName"`
}

func (q *Queries) GetAllUsersPlantsOrderedByUpdated(ctx context.Context, userID uuid.UUID) ([]GetAllUsersPlantsOrderedByUpdatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsersPlantsOrderedByUpdated, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersPlantsOrderedByUpdatedRow
	for rows.Next() {
		var i GetAllUsersPlantsOrderedByUpdatedRow
		if err := rows.Scan(
			&i.UsersPlantID,
			&i.AdoptionDate,
			&i.PlantName,
			&i.UpdatedAt,
			&i.PlantSpeciesID,
			&i.SpeciesName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersPlantByID = `-- name: GetUsersPlantByID :one
with users_plant as (
  select 
    id, plant_id, adoption_date, name, created_at
  from users_plants
  where
    deleted_at is null and
    user_id = $1 and
    id = $2
)
select
  up.id as users_plant_id,
  up.adoption_date,
  up.name as plant_name,
  up.created_at,
  ps.id as plant_species_id,
  ps.species_name
from
  users_plant as up
join
  plant_species as ps on up.plant_id = ps.id
order by up.created_at desc
limit 1
`

type GetUsersPlantByIDParams struct {
	Column1 uuid.NullUUID `json:"column1"`
	Column2 uuid.NullUUID `json:"column2"`
}

type GetUsersPlantByIDRow struct {
	UsersPlantID   uuid.UUID      `json:"usersPlantID"`
	AdoptionDate   sql.NullTime   `json:"adoptionDate"`
	PlantName      sql.NullString `json:"plantName"`
	CreatedAt      time.Time      `json:"createdAt"`
	PlantSpeciesID uuid.UUID      `json:"plantSpeciesID"`
	SpeciesName    string         `json:"speciesName"`
}

func (q *Queries) GetUsersPlantByID(ctx context.Context, arg GetUsersPlantByIDParams) (GetUsersPlantByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUsersPlantByID, arg.Column1, arg.Column2)
	var i GetUsersPlantByIDRow
	err := row.Scan(
		&i.UsersPlantID,
		&i.AdoptionDate,
		&i.PlantName,
		&i.CreatedAt,
		&i.PlantSpeciesID,
		&i.SpeciesName,
	)
	return i, err
}

const updateUsersPlantByID = `-- name: UpdateUsersPlantByID :exec
update users_plants
set updated_at = now(),
  updated_by = $2,
  adoption_date = $3,
  name = $4
where id = $1
  and deleted_at is null
`

type UpdateUsersPlantByIDParams struct {
	ID           uuid.UUID      `json:"id"`
	UpdatedBy    uuid.UUID      `json:"updatedBy"`
	AdoptionDate sql.NullTime   `json:"adoptionDate"`
	Name         sql.NullString `json:"name"`
}

func (q *Queries) UpdateUsersPlantByID(ctx context.Context, arg UpdateUsersPlantByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateUsersPlantByID,
		arg.ID,
		arg.UpdatedBy,
		arg.AdoptionDate,
		arg.Name,
	)
	return err
}
