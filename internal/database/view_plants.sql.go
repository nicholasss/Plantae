// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: view_plants.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const getAllViewPlantsOrderedByUpdated = `-- name: GetAllViewPlantsOrderedByUpdated :many
select
  ps.id as plant_species_id,
  ps.species_name as plant_species_name,
  ps.human_poison_toxic,
  ps.pet_poison_toxic,
  ps.human_edible,
  ps.pet_edible,
  nullif(max(pn.lang_code), '') as lang_code,
  nullif(string_agg(pn.common_name, ', '), '') as common_names,
  pt.name as plant_type_name,
  pt.description as plant_type_description,
  ln.name as light_need_name,
  ln.description as light_need_description,
  wn.plant_type as water_need_type,
  wn.description as water_need_description,
  wn.dry_soil_mm as water_need_dry_soil_mm,
  wn.dry_soil_days as water_need_dry_soil_days
from
  plant_species as ps
left join
  plant_names as pn on ps.id = pn.plant_id
left join
  plant_types as pt on ps.plant_type_id = pt.id
left join
  light_needs as ln on ps.light_needs_id = ln.id
left join
  water_needs as wn on ps.water_needs_id = wn.id
where
  (pn.lang_code = $1 or pn.lang_code is null) and
  ps.deleted_at is null and
  pn.deleted_at is null and
  ln.deleted_at is null and
  wn.deleted_at is null
group by
  ps.id,
  ps.species_name,
  ps.human_poison_toxic,
  ps.pet_poison_toxic,
  ps.human_edible,
  ps.pet_edible,
  pt.name,
  pt.description,
  ln.name,
  ln.description,
  wn.plant_type,
  wn.description,
  wn.dry_soil_mm,
  wn.dry_soil_days
order by
  ps.updated_at desc
`

type GetAllViewPlantsOrderedByUpdatedRow struct {
	PlantSpeciesID       uuid.UUID      `json:"plantSpeciesID"`
	PlantSpeciesName     string         `json:"plantSpeciesName"`
	HumanPoisonToxic     sql.NullBool   `json:"humanPoisonToxic"`
	PetPoisonToxic       sql.NullBool   `json:"petPoisonToxic"`
	HumanEdible          sql.NullBool   `json:"humanEdible"`
	PetEdible            sql.NullBool   `json:"petEdible"`
	LangCode             sql.NullString `json:"langCode"`
	CommonNames          sql.NullString `json:"commonNames"`
	PlantTypeName        sql.NullString `json:"plantTypeName"`
	PlantTypeDescription sql.NullString `json:"plantTypeDescription"`
	LightNeedName        sql.NullString `json:"lightNeedName"`
	LightNeedDescription sql.NullString `json:"lightNeedDescription"`
	WaterNeedType        sql.NullString `json:"waterNeedType"`
	WaterNeedDescription sql.NullString `json:"waterNeedDescription"`
	WaterNeedDrySoilMm   sql.NullInt32  `json:"waterNeedDrySoilMm"`
	WaterNeedDrySoilDays sql.NullInt32  `json:"waterNeedDrySoilDays"`
}

func (q *Queries) GetAllViewPlantsOrderedByUpdated(ctx context.Context, langCode sql.NullString) ([]GetAllViewPlantsOrderedByUpdatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllViewPlantsOrderedByUpdated, langCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllViewPlantsOrderedByUpdatedRow
	for rows.Next() {
		var i GetAllViewPlantsOrderedByUpdatedRow
		if err := rows.Scan(
			&i.PlantSpeciesID,
			&i.PlantSpeciesName,
			&i.HumanPoisonToxic,
			&i.PetPoisonToxic,
			&i.HumanEdible,
			&i.PetEdible,
			&i.LangCode,
			&i.CommonNames,
			&i.PlantTypeName,
			&i.PlantTypeDescription,
			&i.LightNeedName,
			&i.LightNeedDescription,
			&i.WaterNeedType,
			&i.WaterNeedDescription,
			&i.WaterNeedDrySoilMm,
			&i.WaterNeedDrySoilDays,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
