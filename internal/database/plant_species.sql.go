// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: plant_species.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createPlantSpecies = `-- name: CreatePlantSpecies :one
insert into plant_species (
	id, created_at, updated_at, deleted_at,
	created_by, updated_by, deleted_by, species_name,
	human_poison_toxic, pet_poison_toxic,
	human_edible, pet_edible
) values (
	gen_random_uuid(), now(), now(), now(), $1, $2, $3, $4, $5, $6, $7, $8
) returning id, created_at, updated_at, deleted_at, created_by, updated_by, deleted_by, species_name, human_poison_toxic, pet_poison_toxic, human_edible, pet_edible
`

type CreatePlantSpeciesParams struct {
	CreatedBy        interface{}
	UpdatedBy        interface{}
	DeletedBy        interface{}
	SpeciesName      string
	HumanPoisonToxic sql.NullBool
	PetPoisonToxic   sql.NullBool
	HumanEdible      sql.NullBool
	PetEdible        sql.NullBool
}

func (q *Queries) CreatePlantSpecies(ctx context.Context, arg CreatePlantSpeciesParams) (PlantSpecy, error) {
	row := q.db.QueryRowContext(ctx, createPlantSpecies,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.DeletedBy,
		arg.SpeciesName,
		arg.HumanPoisonToxic,
		arg.PetPoisonToxic,
		arg.HumanEdible,
		arg.PetEdible,
	)
	var i PlantSpecy
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.SpeciesName,
		&i.HumanPoisonToxic,
		&i.PetPoisonToxic,
		&i.HumanEdible,
		&i.PetEdible,
	)
	return i, err
}

const getAllPlantSpeciesOrderedByCreated = `-- name: GetAllPlantSpeciesOrderedByCreated :many
select id, created_at, updated_at, deleted_at, created_by, updated_by, deleted_by, species_name, human_poison_toxic, pet_poison_toxic, human_edible, pet_edible from plant_species
  order by created_at desc
`

func (q *Queries) GetAllPlantSpeciesOrderedByCreated(ctx context.Context) ([]PlantSpecy, error) {
	rows, err := q.db.QueryContext(ctx, getAllPlantSpeciesOrderedByCreated)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlantSpecy
	for rows.Next() {
		var i PlantSpecy
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DeletedBy,
			&i.SpeciesName,
			&i.HumanPoisonToxic,
			&i.PetPoisonToxic,
			&i.HumanEdible,
			&i.PetEdible,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPlantSpeciesOrderedByUpdated = `-- name: GetAllPlantSpeciesOrderedByUpdated :many
select id, created_at, updated_at, deleted_at, created_by, updated_by, deleted_by, species_name, human_poison_toxic, pet_poison_toxic, human_edible, pet_edible from plant_species
  order by updated_at desc
`

func (q *Queries) GetAllPlantSpeciesOrderedByUpdated(ctx context.Context) ([]PlantSpecy, error) {
	rows, err := q.db.QueryContext(ctx, getAllPlantSpeciesOrderedByUpdated)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlantSpecy
	for rows.Next() {
		var i PlantSpecy
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DeletedBy,
			&i.SpeciesName,
			&i.HumanPoisonToxic,
			&i.PetPoisonToxic,
			&i.HumanEdible,
			&i.PetEdible,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlantSpeciesByID = `-- name: GetPlantSpeciesByID :one
select id, created_at, updated_at, deleted_at, created_by, updated_by, deleted_by, species_name, human_poison_toxic, pet_poison_toxic, human_edible, pet_edible from plant_species
  where id = $1
  limit 1
`

func (q *Queries) GetPlantSpeciesByID(ctx context.Context, id uuid.UUID) (PlantSpecy, error) {
	row := q.db.QueryRowContext(ctx, getPlantSpeciesByID, id)
	var i PlantSpecy
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.SpeciesName,
		&i.HumanPoisonToxic,
		&i.PetPoisonToxic,
		&i.HumanEdible,
		&i.PetEdible,
	)
	return i, err
}

const getPlantSpeciesByName = `-- name: GetPlantSpeciesByName :one
select id, created_at, updated_at, deleted_at, created_by, updated_by, deleted_by, species_name, human_poison_toxic, pet_poison_toxic, human_edible, pet_edible from plant_species
	where species_name like $1
  limit 1
`

func (q *Queries) GetPlantSpeciesByName(ctx context.Context, speciesName string) (PlantSpecy, error) {
	row := q.db.QueryRowContext(ctx, getPlantSpeciesByName, speciesName)
	var i PlantSpecy
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
		&i.SpeciesName,
		&i.HumanPoisonToxic,
		&i.PetPoisonToxic,
		&i.HumanEdible,
		&i.PetEdible,
	)
	return i, err
}

const markAsDeletedPlantSpeciesByID = `-- name: MarkAsDeletedPlantSpeciesByID :exec
update plant_species
  set deleted_at = now(),
  deleted_by = $2
where id = $1
`

type MarkAsDeletedPlantSpeciesByIDParams struct {
	ID        uuid.UUID
	DeletedBy interface{}
}

func (q *Queries) MarkAsDeletedPlantSpeciesByID(ctx context.Context, arg MarkAsDeletedPlantSpeciesByIDParams) error {
	_, err := q.db.ExecContext(ctx, markAsDeletedPlantSpeciesByID, arg.ID, arg.DeletedBy)
	return err
}

const updatePlantSpeciesByID = `-- name: UpdatePlantSpeciesByID :exec
update plant_species
  set human_poison_toxic = $2,
	pet_poison_toxic = $3,
	human_edible = $4,
  pet_edible = $5
where id = $1
`

type UpdatePlantSpeciesByIDParams struct {
	ID               uuid.UUID
	HumanPoisonToxic sql.NullBool
	PetPoisonToxic   sql.NullBool
	HumanEdible      sql.NullBool
	PetEdible        sql.NullBool
}

func (q *Queries) UpdatePlantSpeciesByID(ctx context.Context, arg UpdatePlantSpeciesByIDParams) error {
	_, err := q.db.ExecContext(ctx, updatePlantSpeciesByID,
		arg.ID,
		arg.HumanPoisonToxic,
		arg.PetPoisonToxic,
		arg.HumanEdible,
		arg.PetEdible,
	)
	return err
}
